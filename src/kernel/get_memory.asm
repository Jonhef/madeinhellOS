; memory.asm
section .data
    buffer resb 24         ; Буфер для хранения записи о сегменте памяти
    memory_size dd 0       ; Переменная для хранения общего объема памяти

section .text
global get_memory_size    ; Делаем функцию доступной для C

get_memory_size:
    xor eax, eax           ; Очистка регистра
    mov esi, buffer        ; Адрес буфера для хранения записи о сегменте
    mov ebx, 0             ; Инициализация ebx нулем (начинаем с первого сегмента)
    mov eax, 0xE820        ; Функция e820h для получения информации о памяти
    mov edx, 0x534D4150    ; Магическое число 'SMAP'
    mov ecx, 24            ; Размер буфера (24 байта)
    mov edi, 20            ; Флаг возврата полной карты

e820_loop:
    int 0x15               ; Вызов BIOS для получения карты памяти
    jc end_get_memory_size ; Если ошибка, выход

    cmp eax, 0x534D4150    ; Проверка магического числа
    jne end_get_memory_size ; Если магическое число не совпадает, выход

    ; Обработка буфера
    ; Buffer layout:
    ; [0..7]  = Base Address (начало сегмента)
    ; [8..15] = Length (длина сегмента в байтах)
    ; [16..19] = Type (тип сегмента)

    test dword [esi + 16], 1 ; Проверка типа сегмента (1 = доступная память)
    jnz next_segment         ; Если не доступная память, переходим к следующему сегменту

    ; Добавляем объем памяти к общему размеру (в байтах)
    add [memory_size], dword [esi + 8]

next_segment:
    test ebx, ebx            ; Если EBX = 0, больше нет сегментов
    jnz e820_loop            ; Если есть еще сегменты, продолжаем

end_get_memory_size:
    mov eax, [memory_size]   ; Загружаем общий размер памяти в байтах
    mov ebx, 1024            ; Делим на 1024, чтобы получить килобайты
    div ebx                  ; Делим общий объем на 1024
    ret                      ; Возвращаем результат в EAX
